\section{Glosario de términos}
% ======================================================================



\subsection {Analizador léxico}
Un analizador léxico o scanner es un componente software cuya implementación normalmente se corresponde con un autómata finito. Este se encarga de determinar si una determinada cadena pertenece o no al conjunto de cadenas 
que conforma el léxico del lenguaje. Esta pieza software recibe como entrada un contenido fuente escrito generalmente como cadenas de caracteres, aunque puede soportar otros tipos de codificaciones
(audio, imágenes...), y devuelve un conjunto de tokens correspondientes. \\

\subsection {Analizador sintáctico}
Un analizador sintáctico o parser es un componente software cuya implementación normalmente se corresponde con un autómata de pila (si la gramática es libre de contexto). Este se encarga, ayudado generalmente de un analizador léxico,
de tomar un contenido fuente escrito generalmente como cadena de caracteres (aunque puede soportar otros tipos de codificaciones), y construir una estructura más fácil de analizar y procesar 
(normalmente árboles). El resultado de llevar a cabo un análisis sintáctico normalmente es un árbol de derivación denominado árbol sintáctico. \\

\subsection {Árbol sintáctico}
Árbol de derivación producto del análisis sintáctico. La raíz y demás nodos no hojas se componen de símbolos no terminales, mientras que los nodos hojas se componen únicamente de símbolos
terminales\\

\subsection {Argumento}
Los argumentos son parte de la llamada a una función o procedimiento. Un argumento representa el valor que es asociado a un determinado parámetro cuando es llamado. La definición puede extenderse a los valores que son pasados
a un programa cuando este es ejecutado. Generalmente los argumentos son asociados a los parámetros de una forma posicional.\\

\subsection {Biblioteca de programación}
Una Biblioteca es un conjunto de funciones o componentes de programación agrupados y encapsulados, que se encuentran relacionados y que comparten características afines. 
Su principal función es la reutilización de funcionalidades entre programas. En los lenguajes compilados se pueden distinguir entre bibliotecas dinámicas o estáticas.\\

\subsection {Biblioteca dinámica}
Una Biblioteca de programación es dinámica si se encuentra ya compilada. El programa carga y hace uso de esta en tiempo de ejecución.\\

\subsection {Biblioteca estática}
Una Biblioteca de programación es estática si se encuentran en en un lenguaje de alto nivel. Estas son añadidas y compiladas juntos al programa.\\

\subsection{Clase}
En el contexto de la programación, y más concretamente dentro de la programación orientada a objetos, una clase es una estructura que define un estado por medio de variables, 
denominadas atributos, y un conjunto de operaciones que encapsulan un determinado comportamiento, denominados métodos. Las clases representan una plantilla o modelo a partir de 
la cual se crean objetos o instancias pertenecientes a la misma. \\

\subsection {Código fuente}
El código fuente representa las instrucciones o sentencias que conforman el programa. Generalmente estas se presentarán en un formato de cadena de texto, aunque determinados sistemas
pueden ser presentados en otros formatos como imágenes, audio ...\\

\subsection {Comando}
Instrucción u orden que el usuario proporciona a un sistema informático. El sistema indica al usuario que espera un comando por medio de una cadena de caracteres denominada prompt. \\

\subsection{Compilador}
Programa que traduce un programa escrito en un lenguaje de alto nivel a otro, generalmente de bajo nivel.  \\

\subsection {Constante}
En el ámbito de la programación una constante representa un valor que no varía en el tiempo, por lo que una vez declarado solo podará leerse y no modificarse. El valor constante 
puede estar asociado a un identificador o nombre que se usará para referenciarlo. \\

\subsection{Dato}
Representan la unidad mínima de información. Son valores que los programas manipulan para construir la solución al problema que pretenden resolver.\\

\subsection{Expresión}
Secuencia de símbolos que pertenecen a un lenguaje formal. Las expresiones deben cumplir una serie de reglas determinadas por el lenguaje 
en las que están escritas, de forma que admiten una determinada interpretación dentro del lenguaje y cuya evaluación la atribuirá de valor. 
En los lenguajes de programación una expresión suele ser una combinación de constantes, operadores, funciones y demás recursos del lenguajes. \\

\subsection {Extensión}
Sistema software que se relaciona con otro para extender o añadir funcionalidades de este. El grado de dependencia de las extensiones con la
aplicación base es muy alto y en un solo sentido. \\

\subsection{Función}
En el contexto de la programación una función representa un conjunto de sentencias o instrucciones con un determinado propósito. Las funciones se ejecutan al ser llamadas desde otras
funciones o procedimientos del programa, o incluso desde si misma (funciones recursivas). Las funciones pueden recibir datos desde el punto desde el que son llamadas por medio de los 
denominados parámetros de la función. Las funciones generalmente están diseñadas para devolver un determinado 
valor fruto de la ejecución del algoritmo que codifican o encierran. Las funciones son un elemento de suma importancia dentro de la programación funcional, pero son también muy utilizadas en otros paradigmas de programación, 
tanto declarativos como imperativos. \\

\subsection {Gramática}
Estructura que representa unas reglas de formación que define cadenas o frases que pertenecen a un determinado lenguaje natural o formal. \\

Una gramática es un cuádrupla $ G = (VT, VN, S, P) $, donde: \\

\begin {description}
\item[$VT$:] Conjunto de símbolos terminales.
\item[$VN$:] Conjunto de símbolos no terminales.
\item[$S$:] Símbolo inicial de la gramática, $S\ \epsilon\ VN$.
\item[$P$:] Reglas de derivación.
\end{description}

Los tipos de gramáticas generalmente vienen determinadas por los tipos de reglas de derivación que las componen.\\

\subsection {Gramática libre de contexto}
Son gramáticas cuyas reglas de derivación no dependen de un contexto. Esta son de la 
forma $V\rightarrow w$ donde es $V$ es un símbolo no terminal y $w$ es una cadena de terminales y no terminales.
Las gramáticas libres de contexto originan lenguajes libres de contexto que pueden ser implementados mediante
autómatas de pilas. \\

\subsection{Identificador}
Elemento textual o símbolo que es parte del léxico de un lenguaje y que nombran entidades del mismo como variables, constantes, funciones...\\

\subsection{Interprete}
Programa que ejecuta directamente las sentencias escritas en un lenguaje de programación o de scripts, sin necesidad de compilar estas a un lenguaje de 
bajo nivel. \\

\subsection{Instrucción}
Secuencia de bits que el procesador es capaz de interpretar y ejecutar. Las instrucciones que un determinado procesador es capaz reconocer 
viene determinada por el conjunto de instrucciones del mismo, dado en el momento de su fabricación y según la arquitectura con la que fue diseñado. 
También son consideradas instrucciones las representaciones de estas en lenguajes de nemotécnicos como ensamblador.\\

\subsection{Lenguaje de programación}
Lenguaje formal generalmente usado para crear programas. Con un lenguaje de programación es posible expresar los 
algoritmos que determinan el comportamiento que debe llevar a cabo un determinado programa. Está formado por
un conjunto de símbolos que representa el léxico y un conjunto de reglas sintácticas y semánticas. \\

\subsection{Lenguaje de programación compilados}
Se refiere a aquellos lenguajes de alto nivel tal que, para ser ejecutados, los programas codificados deben ser sometidos a un proceso 
de traducción a lenguajes de bajo nivel. Una vez sometido al proceso de compilación un programa puede ser ejecutado directamente por 
la computadora para la que fue compilada.  \\

\subsection{Lenguaje de programación interpretados}
Se refiere a aquellos lenguajes de alto nivel tal que, para ser ejecutados, los programas codificados deben ser procesados por un intérprete que 
se encargará de obtener su representación a bajo nivel a la vez que lo ejecuta.\\

\subsection{Lenguaje de programación de alto nivel}
Permiten expresar algoritmos de una forma abstracta, adecuada a la capacidad cognitiva humana. Son más cercanos
al lenguaje humano que al lenguaje máquina. Un programa codificado en un lenguaje de alto nivel necesita ser procesado 
y transformado al conjunto de instrucciones que la computadora puede ejecutar. \\

\subsection{Lenguaje de programación de bajo nivel}
Son lenguajes cercanos al hardware, condicionados a la computadora. Derivan del conjunto de instrucciones 
soportados por la máquina, y van desde la representación binaria de estas hasta el uso de nemotécnicos.\\

\subsection{Lenguaje de programación de tipado dinámico}
En los lenguajes de programación de tipado dinámico el tipo de los datos es determinado en tiempo de ejecución. Generalmente el tipo de dato es asociado 
al valor de una variable y no a la variable en si. 
 
\subsection{Lenguaje de programación de tipado estático}
En los lenguajes de programación de tipado estático el tipo de los datos es determinado en tiempo de compilación. Generalmente el tipo de dato es asociado 
a la variable en el momento de su declaración.  \\

\subsection {Módulo}
Parte de un software informático que lleva a cabo una función especifica dentro del conjunto de tareas que esta realiza. Generalmente los módulos
de un programa se encuentran organizados jerárquicamente según el nivel de abstracción que presentan y el objetivo que cumplen.\\

\subsection {Objeto}
En el contexto de la programación, y más concretamente dentro de la programación orientada a objetos, un objeto es una estructura que encapsula un determinado estado (atributos) y a la 
cual se le puede aplicar una serie de operaciones (métodos). Generalmente estos son creados mediante la instanciación de una clase de objeto, que define una serie de objetos con un comportamiento y estados afines.\\

\subsection{Operador}
Símbolo matemático que indica que se debe llevar a cabo una operación determinada sobre un cierto número de operandos. 
El operador toma los elementos iniciales y los relaciona con otro elemento de un conjunto final que puede ser de la misma naturaleza o no.\\

\subsection {Paradigma de programación}
Representa un estilo fundamental de programación, sirve como una forma de construir estructuras y elementos de los programas. Las capacidades y estilos de muchos 
lenguajes de programación son definidos para soportar determinados paradigmas de programación. Algunos lenguajes son diseñados para seguir un único paradigma, mientras
que otros persiguen el soporte para varios de estos. \\

\subsection {Parámetro}
Los parámetros son parte de la signatura de una función o procedimiento. Un parámetro representa un valor que una función o procedimiento espera que sea transferido cuando son llamados. En 
algunos lenguajes de programación, determinados parámetros pueden presentar valores por defectos, que son los que se tomarán si no están presente en la llamada.\\

\subsection{Procedimiento}
Representa un conjunto de actividades, eventos o tareas que son ejecutadas para llevar a cabo un determinado propósito. Estas son codificadas mediante sentencias, llamadas a funciones
u otros recursos del lenguaje. \\

\subsection{Programa}
Secuencia de instrucciones que al ser ejecutadas por una computadora se corresponderán con
la realización de una tarea específica. Para que las instrucciones que conforman un programa puedan ser ejecutadas 
por una determinada computadora deben presentarse en un formato legible por esta, generalmente binario, y deben estar dentro
del conjunto de instrucciones que soporta. \\

\subsection {Programación declarativa}
Los lenguajes declarativos utilizan construcciones matemáticas para describir el problema y así obtener la solución.  
En los lenguajes declarativos puros se cumple una transparencia referencial en todo el sistema por lo
que se evitan efectos colaterales. Además no existen las asignaciones destructivas. Esto marca una diferencia 
con los lenguajes imperativos y es que las funciones declarativas no pueden depender o cambiar el estado del 
programa. Los lenguajes multiparadigma pueden ofrecer estructuras que garanticen estos principios.\\

\subsection {Programación imperativa}
El programa se ve como una entidad que presenta un estado y una serie de sentencias u operaciones que hacen que dicho estado cambie. Este tipo de programación es cercana a la 
máquina, ya que la implementación de la mayoría de computadores a nivel hardware es imperativa. \\

\subsection{Script}
Programa simple, representado por una lista de comandos que serán ejecutados por un determinado programa o motor de scripts. Normalmente son utilizados
para automatizar procesos. Algunos entornos que pueden ser automatizados mediante scripts incluye 
determinadas aplicaciones software, páginas webs, los shells del sistema operativo o sistemas embebidos.\\

\subsection{Sentencia}
Unidad con valor semántico a partir de la cual se construye un lenguaje de alto nivel. Son para los lenguajes de alto nivel lo que las instrucciones
los son para los de bajo nivel. Generalmente se componen de expresiones u otras construcciones propias del lenguaje.\\

\subsection {Signatura}
La signatura de una función o método define el nombre o identificador del mismo, así como los parámetros de los que dispone. En algunos lenguajes puede incluir el tipo de dato de los parámetros 
y el tipo que es devuelto.  \\

\subsection {Tipo array}
Un array o vector representa un conjunto ordenado de valores o elementos del mismo que se encuentran posicionados en memoria de forma contigua. En muchos lenguajes
esta definición suele extenderse a listas de elementos que pueden tener diferente tipo.\\

\subsection {Tipo cadena de caracteres}
Una cadena de caracteres es una secuencia de caracteres, que comprende signos, símbolos, letras o números. En el ámbito de la programación se utiliza normalmente como un tipo de 
dato compuesto, representado mediante un array cuyos elementos son los caracteres que componen la cadena.\\

\subsection {Tipo expresión regular}
Cadena de caracteres que representa un lenguaje regular, normalmente conforman un patrón y son utilizadas para buscar o 
sustituir cadenas dentro de otras. \\

\subsection {Tipo lógico}
Un valor lógico, también denominados booleanos, representa un valor verdadero o falso. Un valor lógico es equivalente a un valor binario 0 ó 1.\\

\subsection {Tipo numérico}
Un valor numérico, también denominados aritméticos, representa un valor entero o real. Un valor entero comprende los números positivos, negativos y el cero. Un valor real
posee una parte entera y otra decimal.\\

\subsection{Tipos de datos}
Según la naturaleza de los datos estos pueden quedar organizados en tipos. Un lenguaje de programación generalmente opera sobre unos tipos de datos 
predefinidos, aunque ofrecen la capacidad de definir tipos de datos más complejos a partir de estos.\\

\subsection{Token}
Elemento léxico con cierto valor para un determinado lenguaje de programación. Normalmente se corresponde con una cadena de
caracteres que se puede corresponder con una palabra reservada, un identificador, un número... Un token puede contener un 
valor.\\

\subsection{Variable}
En el contexto de la programación una variable representa un espacio de almacenaje que contiene un valor (conocido o desconocido) que es asociado a un identificador.
El valor guardado por una variable puede cambiar en el tiempo de ejecución del programa. El tipo de dato que puede almacenar una variable puede estar ligado a la 
variable, por lo que esta sólo podrá almacenar valores de un tipo determinado, o estar asociada al valor en sí por lo que la variable podrá almacenar valores de 
distintos tipos.\\

\section{Análisis previo de mercado}
En esta sección se incluye un análisis previo de mercado que sirva como comparativa sobre los lenguajes de programación presentes y sus principales 
características. El objetivo es determinar las carencias que estos presentan y que podrían ser cubiertas por el lenguaje de programación OMI, a la vez que
se establecen las características de las que dispondrá el software.
Para ello se tomará una muestra significativa y se estudiarán aquellas características consideradas de valor para el análisis.

Los lenguajes de programación tomados como muestra se corresponden con los más utilizados en el año 2014 
según Gartner (consultor tecnológico estadounidense). Esta lista es utilizada como referencia en el mundo tecnológico
por medios especializados (http://blogs.gartner.com/mark\_driver/ 2014/10/02/gartner-programming-language-index-for-2014/).

\begin{itemize}
   \item C/C++
   \item Java
   \item PHP
   \item Python
   \item Ruby
   \item JavaScript \& Node.js (JS)
   \item OMI
\end{itemize}

\subsection{Compilado o interpretado}
Un lenguaje de programación es compilado si el código fuente desarrollado en el mismo 
debe ser traducido a código máquina para su ejecución. En contra partida un lenguaje 
es interpretado si el código fuente es procesado y ejecutado directamente por una pieza software denominado intérprete.

Muchos lenguajes son traducidos a un lenguaje intermedio denominado Bytecode que 
será ejecutado por un intérprete.

Algunos lenguajes interpretados pueden ser compilados a código máquina mediante alguna herramienta
externas generalmente no estándar, estos casos no serán considerados en el análisis. De igual forma
algunos lenguajes que normalmente son compilados pero que disponen de herramientas software capaz de interpretarlo.

 
 \FloatBarrier
\begin{table}[h]
 \begin{center}
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI \\ \hline
Compilado & X &  &  &  &  &  &  \\ \hline
ByteCode &  & X &  &  &  &  &  \\ \hline
Interpretado & & & X & X & X & X & X \\ \hline
\end{tabular}
\caption{Lenguajes compilados e interpretados}
\end{center}
\end{table}
\FloatBarrier

\subsection{Sistema de tipos}
El sistema de tipos hace referencia a cómo el lenguaje clasifica los valores
y expresiones en tipos. Este puede ser estático o dinámico en función si el tipo 
se establece en tiempo de compilación o ejecución. 

Algunos lenguajes de tipado estático presenta mecanismos para escribir código 
que no será comprobado estáticamente, aunque estas implementaciones presentan 
ciertas limitaciones y pueden legar a ser ser inseguras en tiempo de ejecución produciendo resultados inesperados.
 
Por otro lado un lenguaje es fuertemente tipado si no permite usar un dato de un tipo concreto
como si de otro se tratase, a menos que se realice una conversión explícita de tipos. Mientras que es 
débilmente tipado si no controla el tipo de las variables y demás datos que se utilizan. Normalmente
un lenguaje de tipado dinámico es débilmente tipado.
 
 \FloatBarrier
\begin{table}[h]
 \begin{center}
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI \\ \hline
Tipado estático & X & X &  &  &  &  &  \\ \hline
Tipado dinámico & & & X & X & X & X & X \\ \hline
Tipado fuerte & X & X &  &  &  &  &  \\ \hline
Tipado débil  & & & X & X & X & X & X \\ \hline
\end{tabular}
\caption{Lenguajes según sistema de tipos}
\end{center}
\end{table}
\FloatBarrier

\subsection{Tipos de datos}
Los tipos de datos que se pueden describir y manejar en los lenguajes de 
programación suponen un factor diferenciador de importancia entre estos.

Muchos lenguajes presentan tipos de datos que han sido modelados e integrados atendiendo
al paradigma orientado a objetos. Sin embargo muchos tipos de datos pueden ser definidos
de una forma más ágil o descriptiva usando un léxico y gramática propios.   

Existen tipos de datos como las pilas, colas o árboles que son simplificaciones u otras 
implementaciones de otros tipos.

La solución que dan algunos lenguajes para determinados tipos de datos (como los rangos) son en forma 
de otras construcciones del lenguajes como funciones u objetos.

Para profundizar en el tema se podría analizar la representación interna de los
datos en cada lenguaje, para comparar atributos como la optimización de espacio o rangos permitidos. 

 \FloatBarrier
\begin{table}[h]
 \begin{center}
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI \\ \hline
Booleanos & X & X & X & X & X & X & X \\ \hline
Enteros & X & X& X & X & X & X & X \\ \hline
Flotantes & X & X & X & X & X & X & X \\ \hline
Cadenas de caracteres & X & X & X & X & X & X & X \\ \hline
Vectores  & X & X & X & X & X & X & X \\ \hline
Vectores asociativos & X & X & X & X & X & (*) & X \\ \hline 
Expresiones regulares &  & X & X & X & X & X & X \\ \hline
Nulo & X & X & X & X & X & X & X \\ \hline
Funciones & X & X & X & X & X & X & X \\ \hline
Objetos & X & X & X & X & X & X & X \\ \hline
Referencias & X & & X & & & & X \\ \hline
Símbolos o identidades & & & & & X &  &  \\ \hline
Rangos  & & & X & X & X & X &  \\ \hline
Bloques de sentencias & & & & & X & &  \\ \hline 
Tupla  & & & & X & & &  \\ \hline
Tablas &  &  &  &  &  &  & X \\ \hline
Grafos &  &  &  &  &  &  &  \\ \hline
\end{tabular}
\caption{Lenguajes según tipo de datos soportados}
\end{center}
\end{table}
\FloatBarrier

(*) JavaScript realmente no presenta vectores asociativos, no obstantes estos
pueden ser representados mediante objetos. 


\subsection{Paradigmas de programación}

Los lenguajes de programación presentan cierto grado de enfoque en un determinado paradigma. Los hay así 
que son enfocados totalmente a uno único, tratando la mayoría de conceptos según ese criterio. Mientras 
que otros son multiparadigma, presentando  así características, recursos y conceptos de varios de ellos. 

El grado de enfoque en un determinado paradigma de un lenguaje de programación se puede determinar 
por la forma de tratar o modelar los distintos conceptos, y por la cantidad de recursos y características que 
presente a la hora de afrontar problemas según marco que el paradigma supone. 

Los paradigmas no son independientes entre si, es muy común que un determinado paradigma se 
base en otros para su definición y tome parte de sus características. Se consideran así
los paradigmas más comunes o que supongan una base para otros más concretos.

Algunas de las características que serán analizadas pueden ser 
implementadas en determinados lenguajes mediante la concreción de otra más general o mediante el uso de otras más simples. 
Por otro lado existirán lenguajes que contemplen ciertos
conceptos de una forma más directa, integrada en la gramática y más próxima a lo que persigue modelar.

Es común que algunos lenguajes implementen soluciones propias de un determinado paradigma pero en una forma y estilo
propios de otro.


No formará parte del análisis aquellas características que
son comunes en muchos lenguajes actuales: sentencias condicionales, sentencias iterativas, inclusión de ficheros, operadores con
asignación, saltos a etiquetas ...

\subsubsection {Imperativo}
Describe la programación en términos de un flujo de instrucciones que operan sobre el estado del programa. Los lenguajes
imperativos constan de sentencias que permiten controlar este flujo.

Existen paradigmas que toman el imperativo como base, por ejemplo la programación
estructurada, por procedimientos o la modular. 


\FloatBarrier
\begin{table}[h]
\begin{center}
 
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java &  PHP  & Python & Ruby & JS & OMI\\ \hline
Variables de ámbito global  & X &  & X & X & X & X & X \\ \hline
Foreach & & X & X & X & X & X & X \\ \hline
Iteración ágil(*) & &  & &  &  &  & X \\ \hline
Paso de parámetros por defecto & X &  & X & X & X & & X  \\ \hline
Keyword arguments & & &  & X & X & & X  \\ \hline
Número de parámetros arbitrarios & X & X & X & X & X & X &   \\ \hline
Llamada sin respetar signatura  &  &  &  &  &  & X &   \\ \hline
Desempaquetado de parámetros & & & & X & & &  \\ \hline
Acceso a variables no locales & & & & X & & &  \\ \hline
Toda sentencia tiene un valor & & & & & X & &  \\ \hline
\end{tabular}
\caption{Lenguajes imperativos}
\end{center}
\end{table}
\FloatBarrier

(*) La iteración ágil representa una sentencia de control de flujo iterativa 
cuya expresión es mínima en cuanto codificación se refiere. La 
sentencia unicamente se compone de una expresión que representa una secuencia de elementos
y un bloque de sentencias. La expresión de secuencia será valorada según el tipo de dato
que encierra. Así si la expresión es un vector se tomará como 
secuencia los elementos en el mismo, mientras que si es un número se 
tomará la secuencia de números enteros desde 0 al mismo. El bloque de 
sentencias será ejecutado por cada elemento en la secuencia. En cada iteración 
el elemento correspondiente de la secuencia será asignado a un entidad propia del 
lenguaje denominada ``elemento iterado'' y la posición del mismo se asignará a 
otra entidad denominada ``posición del elemento iterado''. Estas entidades permiten el uso 
de un índice numérico para obtener el valor dentro de sentencias de este tipo anidadas. 

\subsubsection{Orientado a objeto}
Describe la programación en términos de objetos que se relacionan entre si. Los objetos son 
estructuras que encapsulan un estado y una funcionalidad. 

La programación orientada a objetos se basa en la programación imperativa.

Los lenguajes programación orientado a objetos normalmente utilizan clases 
para definir un conjunto de objetos que tendrán un comportamiento y estructura afín. 
Los objetos se consideran instancias o materializaciones de las clases.


\FloatBarrier
\begin{table}[h]
\begin{center}
 
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
Visibilidad & X & X & X &  & X &  & X \\ \hline
Definiciones estáticas & X & X & X & X & X &  & X \\ \hline
Polimorfismo & X & X & X & X & X & X & X \\ \hline
Duck typing & & & X & X & X & X & X \\ \hline
Herencia simple  & X & X & X & X & X &  & X \\ \hline
Herencia múltiple  & X & &  & X &  &  &  \\ \hline
Enlace estático dinámico & & & X &  &  &  &  X \\ \hline
Interfaces & & X & X &  &  &  &   \\ \hline
Traits o Mixins & & & X & X & X &  &   \\ \hline
Name mangling & X & X & & X & & &  \\ \hline
Métodos mágicos & & & X & X & X & X & X \\ \hline 
Todo dato es un objeto & & &  & X & X & X & X \\ \hline 
\end{tabular}
\caption{Lenguajes orientados a objetos}
\end{center}
\end{table}
\FloatBarrier

\paragraph{POO basada en prototipos}

En los lenguajes basados en prototipos los objetos son creados directamente o mediante
la copia de otros objetos. En estos lenguajes no se precisa del concepto de clase.

Los prototipos son objetos que serán clonados y de los cuales otros heredarán su
comportamiento y propiedades.

\FloatBarrier
\begin{table}[h]
\begin{center}
 
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java &  PHP  & Python & Ruby & JS & OMI\\ \hline
Creación directa de objetos &  & &  &  &  & X & X \\ \hline
Construcción de prototipos &  & &  &  &  & X &  \\ \hline
Herencia entre prototipos &  & &  &  &  & X &  \\ \hline
\end{tabular}
\caption{Lenguajes orientados a objetos basados en prototipos}
\end{center}
\end{table}
\FloatBarrier

\subsubsection{Dirigida por eventos}
En la programación dirigidas por evento el flujo que sigue la ejecución de un programa viene 
determinado por los sucesos que ocurren en el sistema. Estos se pueden dar por acciones del usuario
o por el propio programa.

Cabe decir que una programación dirigidas por evento no tiene porqué darse en un 
entorno de concurrencia. Un gestor de eventos denominado``event loop" puede operar sobre 
una cola de estos y ejecutarlos secuencialmente.

\FloatBarrier
\begin{table}[h]
\begin{center}
 
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
Detección de eventos & & & & & & X &  \\ \hline
Asociación de eventos & & & & & & X &  \\ \hline  
Creación de eventos & & & & & & X &  \\ \hline  
Lanzador de eventos & & & & & & X &  \\ \hline  
\end{tabular}
\caption{Lenguajes dirigidos por eventos}
\end{center}
\end{table}
\FloatBarrier

\subsubsection{Basada en autómatas}
En la programación basada en autómatas el sistema se modela
como una máquina de estados finita. Es un tipo de paradigma imperativo.

El concepto primario de este paradigma es el estado. Un estado captura 
un momento actual del sistema ($t_0$). Además a partir de un estado se 
deberá conocer todos los estados pasados ($t < t_0$), distinguiéndolos 
así de los futuros ($ t > t_0$). A partir de un conjunto finito 
de estados y una serie de acciones de entradas se conforma un 
autómata.

Aunque con la mayoría de lenguajes imperativos se puede seguir este paradigma no es 
común que ofrezcan características enfocadas en el mismo. Un lenguaje que sí ofrece características propias 
de este paradigma es MetaQuotes.

\FloatBarrier
\begin{table}[h]
\begin{center}
 
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
Definición de estados & & & & & &  &  \\ \hline
Tabla de transiciones & & & & & &  &  \\ \hline
Construcción de autómatas & & & & & &  &  \\ \hline
\end{tabular}
\caption{Lenguajes basados en autómatas}
\end{center}
\end{table}
\FloatBarrier

\subsubsection{Orientado a Aspectos}

Describe la programación valiéndose del concepto de aspecto. Un aspecto es una
funcionalidad que se presenta de forma transversal, ya sea en la totalidad 
del sistema o de una forma dispersa. 

La programación orientada a aspectos persigue la correcta modularización del sistema, separando
aquellas funcionalidades que son comunes a lo largo de toda la aplicación de aquellas
que quedan encapsuladas en componentes. 

Aunque es común ver la programación orientada a aspectos junto la orientada a objetos es posible 
aplicarla junto a otros paradigmas. 

Aunque muchos de los lenguajes expuestos no soportan programación orientada a aspectos
por si mismos, muchos de ellos constan de recursos externos que permiten 
la aplicación de este paradigma. Estos recursos amplían el lenguaje 
añadiendo reglas gramaticales y estructurales. En la mayoría de casos 
el código fuente debe ser preprocesado para obtener un código intermedio
en el lenguaje base. Estos recursos no son considerados en el análisis 
ya que no se puede decir que el lenguaje contemple esta característica por si mismo.

\FloatBarrier
\begin{table}[h]
\begin{center}
 
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
Aspectos & & &  &  &  &  &  \\ \hline
Puntos de corte & & & &  &  &  &  \\ \hline
Consejos   & & & & & & &  \\ \hline
Decoradores   & & & & X & & & X \\ \hline
\end{tabular}
\end{center}
\caption{Lenguajes orientados a aspectos}
\end{table}
\FloatBarrier

\subsubsection {Declarativo}
Los lenguajes declarativos utilizan expresiones matemáticas para describir el problema y así obtener la solución.  

En los lenguajes declarativos puros se cumple una transparencia referencial en todo el sistema por lo
que se evitan efectos colaterales. Además no existen las asignaciones destructivas. Esto marca una diferencia 
con los lenguajes imperativos y es que las funciones declarativas no pueden depender o cambiar el estado del 
programa. Los lenguajes multiparadigma pueden ofrecer estructuras que garanticen estos principios. Un ejemplo de lenguaje 
declarativo es Haskell.

Otros paradigmas son concreciones del paradigma declarativo. 

\FloatBarrier
\begin{table}[h]
\begin{center}
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
Transparencia referencial & & &  &  &  &  &  \\ \hline
Asignaciones no destructivas & & &  &  &  &  &  \\ \hline
\end{tabular}
\end{center}
\caption{Lenguajes declarativos}
\end{table}
\FloatBarrier

\subsubsection {Funcional}
Describe la programación en términos de funciones. Los lenguajes que atienden a 
estos paradigma generalmente son más cercanos al lenguaje matemático que al máquina.
Es un paradigma declarativo. 

Algunos lenguajes integran soluciones características de la programación funcional pero de una forma más próxima a la imperativa.

Cabe decir que algunas características funcionales pueden ser implementadas 
si el lenguaje dispone de otras características básicas, 
por ejemplo la currificación o la aplicación parcial pueden 
ser implementadas si se dispone de funciones de orden superior y de clausura. En estos casos 
no se considera que el lenguaje integre estas características de forma directa.

\FloatBarrier
\begin{table}[h]
\begin{center}
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
Función de orden superior & X & X & X & X & X & X & X \\ \hline
Clausura  &  & X & X & X & X & X & X \\ \hline
Funciones Lambda  &X & X  & X & X & X & X & X \\ \hline
Pliegues & & & X & X & X & X & X \\ \hline
Mapeo de vectores & & & X & X & X & X & X \\ \hline
Filtro de vectores & & & X & X & X & X & X \\ \hline
Continuations &  &  & X & X & X & X &  \\ \hline
Generadores & & & X & X & X & X &  \\ \hline
Lista por comprensión & & &  & X & &  & X \\ \hline
Currificación  & & &  &  &  &  &  \\ \hline
Aplicación parcial & & & & & & & X \\ \hline
Ajuste de patrones & & & & & & &  \\ \hline
Guardas & & & & & & &  \\ \hline
Composición de funciones & & & & & & &  \\ \hline
Infijo para func. binarias & & & & & & &  \\ \hline
Evaluación perezosa & & & & & & &  \\ \hline
Mapeo y pliegue $$(x ==OR \{1,2\})$$ & & & & & & &  \\ \hline
\end{tabular}
\caption{Lenguajes funcionales}
\end{center}
\end{table}
\FloatBarrier

\subsubsection{Lógico}
Describe la programación en términos de reglas lógicas  que serán sometidas
a un motor de inferencias para resolver los problemas planteados. 
Es un paradigma declarativo. 

\FloatBarrier
\begin{table}[h]
\begin{center}
 
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
Hechos & & & & & & &  \\ \hline
Reglas & & & & & & &  \\ \hline
Motor de inferencias & & & & & & &  \\ \hline
\end{tabular}
\caption{Lenguajes lógicos}
\end{center}
\end{table}
\FloatBarrier

\subsubsection{Programación por restricciones}
La programación se describe en términos de restricciones que toda solución debe cumplir, luego el
sistema se encarga de buscar la solución. La programación por restricciones se puede dar sobre distintos
dominios de datos. Es un tipo de paradigma declarativo inicialmente derivado de la programación lógica. Algunos 
lenguajes populares de programación por restricciones son: B-Prolog, CHIP V5 o ECLiPSe.

\FloatBarrier
\begin{table}[h]
\begin{center}
 
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
Restricciones sobre booleanos& & & & & & &  \\ \hline
Restricciones sobre enteros y racionales& & & & & & &  \\ \hline
Restricciones sobre conjuntos finitos & & & & & & &  \\ \hline
\end{tabular}
\caption{Lenguajes dirigidos por restricciones}
\end{center}
\end{table}
\FloatBarrier

\subsubsection{Programación concurrente}
La programación concurrente ofrece soluciones para expresar paralelismo en la ejecución de 
tareas, permitiendo resolver problemas que se dan cuando varios procesos comparten o compiten
por recursos.

La programación concurrente está muy presente en sistemas distribuidos y en interfaces de
usuario.

La programación concurrente estudia y dispone de una serie de técnicas para la sincronización 
y comunicación entre procesos y/o hilos. Estas técnicas pueden ser implementadas o añadidas en forma de recursos externos en todos los lenguajes analizados, pero se estudia la integración de estas con la gramática del lenguaje.

\FloatBarrier
\begin{table}[h]
\begin{center}
 
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
Procesos & X & X & X & X & X  & X & X \\ \hline
Hilos & X & X & X & X & X &  &  \\ \hline
Mutex &  & &  &  & &  &  \\ \hline
Semáforos &  & &  &  & &  &  \\ \hline
Monitores & & & & & &  &  \\ \hline
Bloques sincronizados & & X  & & & &  &  \\ \hline
\end{tabular}
\caption{Lenguajes concurrentes}
\end{center}
\end{table}
\FloatBarrier



\subsubsection{Programación distribuida}
En la programación distribuida el sistema software se despliega 
en varias máquinas que pueden no estar próximas físicamente.  

La programación distribuida ofrece soluciones a problemas de 
comunicación y sincronización entre sistemas que no se
ejecutan bajo un mismo entorno. 

La programación distribuida se produce en un entorno de concurrencia por lo
que ambos paradigmas se encuentran muy relacionados. Ofrece una serie de técnicas para la comunicación entre procesos distribuidos mediante el uso de un canal de comunicación 
denominado socket. 

\FloatBarrier
\begin{table}[h]
\begin{center}
 
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
Sockets & X & X & X & X & X  & X &  \\ \hline
Paso de mensajes & & &  &  &  &  &  \\ \hline
Llamada a Procedimiento Remoto & & &  &  &  &  &  \\ \hline
Modelos de objetos distribuidos & & &  &  &  &  &  \\ \hline
\end{tabular}
\caption{Lenguajes distribuidos}
\end{center}
\end{table}
\FloatBarrier

\subsection{Operadores}
Los lenguajes de programación proporcionan una serie de operadores sobre los
tipos de datos que define: lógicos, aritméticos, acceso...

En en el análisis se tomarán aquellos operadores que supongan un factor 
diferenciador.

\FloatBarrier
\begin{table}[h]
\begin{center}
 
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
Potencia & & & X & X & X  &  & X \\ \hline
División parte entera & & &  & X &   &  &  \\ \hline
Unión de array & & & X & X & X  &  &  \\ \hline
Intersección de array & & &  &  & X  &  &  \\ \hline
Diferencia de array & & &  &  & X  &  &  \\ \hline
Fusión de Nulos  & & & X &  &   &  & X \\ \hline
Ev. cortocircuito booleanos & X & X & X &  &   &  &  \\ \hline
Ev. cortocircuito último valor & &  & & X & X  & X & X \\ \hline
Ternario reducido & &  & X &  &   &  & X \\ \hline
Comparación combinada & & & X &  & X  &  &  \\ \hline
\end{tabular}
\caption{Lenguajes según operadores}
\end{center}
\end{table}
\FloatBarrier



\subsection{Funciones y clases de objetos}
Los lenguajes generales ofrecen conjuntos de funciones y clases de objetos para afrontar problemas de muy distinta naturaleza. Estos pueden 
ser propios del lenguaje o ser añadidas mediante el uso de bibliotecas, módulos, extensiones... 

Cada problema puede requerir soluciones propias. Los lenguajes de programación ofrecen gran variedad de recursos en
forma de funciones o clases de objetos para dar solución a problemas comunes. No es objetivo de este análisis profundizar en este aspecto. 
No obstante cabe decir que existen determinadas categorías de recursos que pueden ser útiles en gran variedad de escenarios:

\begin{itemize}
   \item Llamadas al sistema
   \item Fechas
   \item Ficheros
   \item Procesos
   \item i18n/l10n
   \item Bases de datos 
   \item Matemáticas 
   \item Sistema de ficheros 
   \item Aleatoriedad 
   \item Protocolos y formatos de internet 
\end{itemize}

\subsection{Definición de lenguajes específicos de dominio}
Los lenguajes específicos de dominio son lenguajes enfocados a un problema
o marco de problemas concretos. Existen lenguajes generales que permiten definir 
otros lenguajes destinados a un dominio específico. 

Los DSL internos son lenguajes especificados a partir de la gramática y forma del
lenguaje base sobre el que se escribe. La flexibilidad a la hora de escribir DSL internos depende en 
gran medida de la gramática y forma del lenguaje genérico. Existen lenguajes cuya 
gramática es muy flexible en este aspecto.

Los DSL externos son lenguajes que no están sujetos a la gramática y forma del 
lenguaje base. Debido a esto son más flexibles que los internos.

Aunque es posible escribir un DSL interno o externo en cada uno de los lenguajes referenciados,
muchos de ellos no presentan características destinadas a tal fin y/o constan de ciertas limitaciones.

Es posible atribuirle a una gramática características como herencia, modularidad... Existen lenguajes 
especializados en escribir gramáticas como bison o ANTLR.

El léxico de muchos lenguajes está conformado por cadena de caracteres que serán reconocidos,
no obstante un lenguaje puede utilizar un léxico de otra naturaleza como sonidos,
secuencia de eventos, grupos de píxeles, componentes de un diagrama...

Los DSL generados pueden ser creados e interpretados en tiempo de ejecución o añadidos
mediante módulos compilados al interprete base.

\FloatBarrier
\begin{table}[h]
\begin{center}
 
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
DSL interno & & &  &  &  X &   &  \\ \hline
DSL externo & & &  &  &  &  &  \\ \hline
Léxico flexible & & &  &  &  &  &  \\ \hline
\end{tabular}
\caption{Lenguajes según DSL}
\end{center}
\end{table}
\FloatBarrier

\subsection{Depuración}
Algunos lenguajes presentan características para la depuración de los programas que se escriben 
sobre ellos. Muchos pueden ser depurados mediante herramientas u otros recursos 
externos. 

\FloatBarrier
\begin{table}[h]
\begin{center}
 
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
Asertos   & & & X & X &  X & X  &  \\ \hline
Depurador integrado & & & X & X & X & X &  \\ \hline
\end{tabular}
\caption{Lenguajes según depuración}
\end{center}
\end{table}
\FloatBarrier


\subsection{Autodocumentación del proceso de interpretación} 
Un lenguaje puede tener la capacidad de autoexplicarse, por ejemplo puede dar información 
paso a paso sobre el proceso llevado a cabo para la interpretación, permitir 
seguir el flujo de ejecución o dibujar gráficas de rendimiento y espacio consumidos.

Para que el interprete/compilador presente autodocumentación debe ser capaz de dar información sobre todo 
el proceso. Además si integra mecanismo para generar DSL deberá documentar también los procesos
aplicados a estos. 

\FloatBarrier
\begin{table}[h]
\begin{center}
 
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
Análisis léxico & &  &  &  &   &   &  \\ \hline
Autómata léxico & & &  &  &   &   &  \\ \hline
Análisis sintáctico & & &  &  &   &   &  \\ \hline
Árbol sintáctico & & &  &  &   &   & X \\ \hline
Aplicación semántica & & &  &  &   &   & X \\ \hline
Árbol de análisis decorado & & &  &  &   &   & X \\ \hline
Estados de la tabla de símbolos & & &  &  &   &   & X \\ \hline
Tiempos de ejecución & & &  &  &   &   &  \\ \hline
Espacio de memoria ocupado & & &  &  &   &   & X \\ \hline
Depurador integrado & & &  &  &   &   & X \\ \hline
\end{tabular}
\caption{Lenguajes autodocumentados}
\end{center}
\end{table}
\FloatBarrier



\subsection{Otras características funcionales}
En este punto se presentan funciones que cumplen algunos lenguajes
y que no han sido categorizadas, pero que aportan 
valor al análisis.

\FloatBarrier
\begin{table}[h]
\begin{center}
 
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
Constantes & X & X & X & & X & X &  \\ \hline
Expresiones con sigilo & & & X & & & &  \\ \hline
Extensiones & & & X & X & X &   & X \\ \hline
Reflexión & & X & X & X & X & X &  \\ \hline
Introspección de tipos & X & & X & X & X & &  \\ \hline
Incrustable en otros documentos & & & X &  & & &  \\ \hline
Acceso a estructuras de bajo nivel & X &  &  &  &  &  &  \\ \hline
Docstring integrado & & &  & X &   &  &  \\ \hline
Interprete interactivo & & & X & X & X & X & X \\ \hline
Excepciones  & X & X & X & X & X & X & X \\ \hline
Espacio de nombres & X & X & X & X & X & X &  \\ \hline
IPC integrado & & &  &  &  &  &  \\ \hline
ORM integrado & & & & & & & X \\ \hline
Patrones de diseño integrados & & & & & & & X \\ \hline
Recolección de Basura & & X & X & X & X & X & X \\ \hline 
Principio de ocultación &X & X & X & & & &  \\ \hline
Niveles de aviso y errores & & & X & & & &  \\ \hline
\end{tabular}
\caption{Lenguajes según otras características funcionales}
\end{center}
\end{table}
\FloatBarrier

\subsection {Características no funcionales}
\subsubsection{Modularidad}
Un interprete se puede presentar de forma modular según diferentes criterios:

\paragraph{Modularidad de recursos}
Un lenguaje es modular en este sentido si tiene la capacidad de ampliar o configurar los recursos que brinda mediante módulos 
que encapsulan construcciones del lenguaje. Las construcciones 
(funciones y clases generalmente) encapsuladas en un módulo cumplen un propósito específico
que puede ser útil en determinados problemas. Este tipo de módulos
generalmente serán compilados de forma independiente y cargados dinámicamente, pero 
también pueden ser compilados junto el binario que representa el interprete.

La mayoría de lenguajes actuales son ampliable en recursos. 

\FloatBarrier
\begin{table}[h]
\begin{center}
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
Modularización de recursos & X & X & X & X & X &   & X \\ \hline
\end{tabular}
\end{center}
\caption{Lenguajes según modularidad de recursos}
\end{table}
\FloatBarrier

\paragraph{Modularidad del lenguaje}
El interprete puede tener una arquitectura interna modular, de forma que el 
lenguaje que representa puede ser extendido o personalizado tanto 
en léxico, como en gramática o en semántica.  Estos módulos, que definen
el lenguaje, pueden ser cargados en tiempo de ejecución o compilados junto 
al interprete.

Un lenguaje modular no es un lenguaje en si, sino un una base para construir otros 
lenguajes. A partir de un lenguaje de este tipo se pueden construir otros lenguajes,
por ejemplo si se toma los módulos adecuados para construir el interprete
se puede obtener un lenguaje puramente matemático.

Es necesario aclara que aunque el interprete tenga la capacidad de generar e interpretar lenguajes
específicos de dominio, no quiere decir que brinde un lenguaje modular ya que las gramáticas
generadas de esta forma se pueden ver como recursos del propio lenguaje. Un lenguaje capaz de generar 
DSL es modular en este sentido si el interprete que lo procesa puede compilarse sin esta característica.

\FloatBarrier
\begin{table}[h]
\begin{center}
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
Modularización del lenguaje & & &  &  &  &   &  \\ \hline
\end{tabular}
\caption{Lenguajes según modularidad del propio lenguaje}
\end{center}
\end{table}
\FloatBarrier


\subsubsection{Licencia}
Todos los interpretes tomados en el análisis presentan licencias propias, pero es
posible analizar las características de estas:

En este análisis se considerará únicamente la licencia de Node.js como JS
dado que cada motor JavaScript dispone de su propia licencia. 

Las licencias de C/C++ dependen del compilador tomado en el análisis, considerándose el 
compilador G++ de GNU.

Para Java se tomará la plataforma desarrollada por Sun Microsystems, aunque   
existen otras a las que se le aplican diferentes términos de licencia de uso.

\FloatBarrier
\begin{table}[h]
\begin{center}
\begin{tabular}{|r|c|c|c|c|c|c|c|} \hline
 & C/C++ & Java & PHP  & Python & Ruby & JS & OMI\\ \hline
Software libre & X &  & X & X & X & X  &  X \\ \hline
Compatible con DFSG & X & &  & X & X & X  &  X\\ \hline
Aprobada por OSI & X & & X & X & X &  X &  X\\ \hline
Compatible GPL & X & &  & X & X  & X  &  X \\ \hline
Copyleft & X & &  & & X &   &  X\\ \hline
Utilizable junto con otras licencias & X & &  & X & X &  X &  X\\ \hline
\end{tabular}
\caption{Lenguajes según licencia}
\end{center}
\end{table}
\FloatBarrier

\subsubsection{Rendimiento}
El rendimiento supone una característica muy valorada en los lenguajes de programación. 
Debido a la gran cantidad de algoritmos que pueden ser codificados y la diversidad de estos, se hace difícil un análisis exhaustivo del rendimiento.
No obstante existen una serie de benchmarks muy popularizados y estandarizados. Incluso se pueden ver proyectos dedicados a someter 
a los lenguajes de programación a un conjunto de estos benchmark (The Computer Language Benchmarks Game: http://benchmarksgame.alioth.debian.org/).

\subsubsection{Productividad}
Los lenguajes de programación deben perseguir la productividad de sus usuarios, para ello deben presentar: 
\begin{itemize}
\item Léxico estándar, uniforme y sencillo.
\item Gramática clara y directa.
\item Estructuras estándar y uniforme.
\end{itemize}

Aunque todos los lenguajes analizados presentan estas características en mayor o menor grado, no es objetivo 
de este análisis entrar en discusión al respecto.

\subsubsection{Portabilidad}
Una característica común en muchos interpretes y compiladores es que se presentan como software multiplataforma,
siendo posible su uso en la mayoría de sistemas operativos actuales. 

La portabilidad es una característica muy valorada, pero que no supone un factor diferenciador dado que la mayoría 
lo cumplen. 

%~ \subsection{Referencias y recursos bibliográficos}
%~ 
%~ Portales webs sobre los lenguajes nombrados en el análisis:
%~ \begin{itemize}
%~ \item isocpp.org: Estándar C++.
%~ \item cplusplus.com: C++ referencias y tutoriales.
%~ \item docs.oracle.com: Java Platform, Standard Edition.
%~ \item php.net: PHP documentación y referencias.
%~ \item python.org: Python documentación y referencias.
%~ \item ruby-lang.org: Ruby documentación y referencias.
%~ \item w3schools.com: JavaScript tutoriales y referencias W3C.
%~ \item developer.mozilla.org: JavaScript tutoriales y referencias Mozilla.
%~ \item nodejs.org: Node.js documentación y referencias.
%~ \end{itemize}
%~ 
%~ Portales webs sobre lenguajes no nombrados en el análisis:
%~ \begin{itemize}
%~ \item uam.es: Manual básico LISP.
%~ \item haskell.org: Haskell documentación y referencias.
%~ \item swi-prolog.org: Prolog documentación y referencias.
%~ \item perl.org: Perl documentación y referencias.
%~ \item scala-lang.org: Scala documentación y referencias.
%~ \end{itemize}
%~ 
%~ Otros recursos generales:
%~ \begin{itemize}
%~ \item wikipedia.org
%~ \item stackoverflow.com
%~ \end{itemize}

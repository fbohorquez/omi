\section{Introdución}
Los juegos de mesas acompañan a la humanidad desde hace muchos años, llenando tiempo de ocio y ayudando a ejercitar las mentes más brillantes. Los juegos de mesa más antiguos conocidos
datan del Antiguo Egipto, pero es muy probable que apareciera mucho antes. Los juegos de mesa permiten pasar un buen rato con la familia y amigos a la vez que capacitan la mente de los jugadores 
en gran diversidad de aspectos como la estrategía, el análisis, la imaginación, el aprendizaje... 

A día de hoy, la era digital ha llevado a los juegos de mesa tradicionales a un segundo nivel reduciendose su uso considerablemente. A pesar de que muchos juegos de mesa clásicos y modernos han sido digitalizados,
la mayoría de estos no han sido desarrollados bajo un estándar y metodología universal, la mayoría son cerrados y, a diferencia de su equivalente en formato físico, no permiten la personalización.
No existe una herramienta en el mercado que permita el desarrollo digital de un juego de mesa de forma rápida y sencilla, y que a la vez sea cercana a la tarea de desarrollarlo en su 
formato físico. 

Rules es un lenguaje de programación diseñado para digitalización de juegos de mesa. El lenguaje presenta una seríe de características que permite llevar a cabo esta tarea de forma ágil.

En esta sección introductoria se presentará a Rules como el lenguaje de programación que es, para luego describir en qué consiste la digitalización de juegos de mesa y cómo
este lenguaje permite la abstracción y simplificación de esta tarea. 

\subsection{¿Qué es Rules?}
Rules es un lenguaje de programación, es decir, un lenguaje formal diseñado para expresar algoritmos que serán ejecutados por una computadora.  

Aunque bien se puede utilizar Rules para resolver cualquier tipo de tarea como la realización de cálculo matemáticos, accesos a bases de datos, 
comunicación entre computadoras..., es considerado un lenguaje de propósito específico dentro del ámbito de la digitalización de juegos de mesa. 
El lenguaje Rules presenta una serie de características que agilizan esta tarea.

Se presenta como un lenguaje de programación de alto nivel, ya que opera sobre conceptos generales y presenta un nivel de abstracción alto. Sin embargo, no es posible afirmar que Rules sea un lenguaje ceracano 
al humano en su totalidad.

Rules se presenta como un lenguaje de programación interpretado, dado que un programa codificado mediante este lenguaje será ejecutado por un software denominado interprete. 
El interprete Rules lee, analiza y ejecuta cada una de las intrucciones codificadas. Además establece un entorno de recursos software accesibles desde el programa en ejecución.  

Este es un lenguaje de programación imperativo por lo que los problemás son resuletos indicando cómo se han de resolver. Sin embargo muchos problemas comprendidos dentro del ámbito 
de la digitalización de juegos de mesas son resueltos de una forma declarativa.

Permite aplicar un paradigma de programación imperativo, pero también soporta programación orientada a objetos basada en prototipos. Rules ofrece mecanismos que permiten definir un juego
de mesa de forma declariva, estos dan solución a problemas comunes dentro del ámbito y permiten definir el entorno de ejecución.

Rules ofrece dos niveles de abstracción cuando su uso es la digitalización de un juego de mesa. Por un lado permite al programador construir componentes del sistema de forma imperativa, ofreciendo 
mecanismos para manipular variables, funciones, expresiones, tipos de datos...  Por otro permite usar estos componentes, junto con otros propios del lenguaje, de una forma declarativa y
 a un nivel mayor de abstracción. Además ofrece al programador mecanismos para definir los conceptos y datos relacionados con el juego.  

Es un lenguaje de programación débilmente tipado y dinámico, dado que no es necesario declarar el tipo de dato, quedando el este asociado al valor y no a la variable. En un momento dado una variable puede estar ligada a 
un entero, y en otro punto de la ejecución a una cadena.  

Rules es un lenguaje que permite la concurrencia de procesos y llamadas al sistema operativo sobre el que se ejecuta.

Al ser un lenguaje modular y extensible, permite añadirle nuevas funcionalidades y características mediante modulos dinámicos.

\subsection{Características generales del lenguaje}
\begin{itemize}
\item Gestión de variables, simples y compuestas, globales y locales
\item Estrucutras de control de flujo: include, if, for, while...
\item Operaciones lógicas
\item Operaciones aritméticas
\item Operaciones con cadenas
\item Operaciones con expresiones regulares
\item Operaciones con vectores
\item Definición y manejo de funciones
\item Definición y manejo de clases
\item Llamadas al sistema
\end{itemize}

Además de estas caracteríticas generales, similares a la de cualquier lenguaje de programación actual, rules ofrece una serie de características y recursos para el desarrollo de juegos de mesa.

\subsection {Digitalización de juegos de mesa}

Un juego de mesa originalmente representa un juego destinado a ser jugado por uno o varios jugadores al rededor de una mesa o similar. Los juegos de mesa se definen mediante una serie de componentes y unas reglas.
 
Los componentes se corresponden con entidades físicas o lógicas que son utilizadas en el juego, por ejemplo cartas, fichas, casillas, etc. Un componente tienen una serie de atributos que lo define y le dan valor en el juego.
Aunque muchos juegos de mesa carecen de componentes físicos cuentan con elementos que se pueden ver como componentes lógicos. En un juego de palabras, por ejemplo, las propias palabras podrían verse como 
componentes lógicos.

Las reglas representan la lógica aplicada al juego. Estas determinan la finalidad y dinámica del juego, en otras palabras, dicen cómo se juega. Para ello especifican una serie de pasos que se ejecutan hasta que se da 
una condición de finalización. Las reglas operan sobre el conjunto de componentes del juego, incluso es común que los componentes tengan reglas asociadas. Muchos juegos de mesa comienzan con una configuración 
o preparación que forma parte de la lógica de juego. Las reglas de un juego de mesa establecen una serie de acciones que los jugadores pueden o deben realizar, estas pueden estar sujetas a unas condiciones.

La actividad de juego se da cuando un conjunto de jugadores aplican o ejecutan unas reglas sobre una serie de componentes. En cada paso de la ejecución de las reglas se obtiene un estado de juego. Al aplicar las 
reglas en función las acciones de los jugadores y el estado del juego se obtiene un nuevo estado de juego. Las reglas se ejecutan  hasta obtener un estado de juego de finalización. 

   



que
representan elementos físicos tales como cartas, fichas, etc. Y una serie de reglas que 
 
que 

La digitalización de los juegos de  tableros consiste en la tarea de tomar un juego de tablero en su formato físico 

Un 
juego de mesa digitalizado mediante Rule presenta dos niveles  

 


Un juego de mesa se puede ver como un algoritmo que representado por las reglas del juego. Este algoritmo opera sobre una serie de componentes físicos y lógicos a partir de las acciones y decisiones de 
los jugadores, que conforman a su vez los parámetros de entrada. Como salida de la ejecución del algoritmo se obtiene una serie de ganadores. 

game {
  name: "Ajedrez",
  players: 2,
  board {
    (i<8, j<8) {
      tile {
        name: "tile_".i."_".j,
        color: ((i + j) % 2),
        'i': i,
        'j': j,
      }
    }
  }
  (i<2) {
    "token_jugador_".i {
      name: "rey_".j,
      class: "token",
      color: i,
      'i': (i == 0)?0:7, 
      'j': 4, 
      can_move: function (token, tile) {
        return 
          (token.i == tile.i + 1 && (token.j == tile.j +2 || token.j == tile.j -2)) || 
          (token.i == tile.i + 2 && (token.j == tile.j +1 || token.j == tile.j -1)) || 
          (token.i == tile.i - 1 && (token.j == tile.j +2 || token.j == tile.j -2)) || 
          (token.i == tile.i - 2 && (token.j == tile.j +1 || token.j == tile.j -1));
      }
    }
    (j<2) "token_jugador_".i {
      name: "caballo_".j,
      class: "token",
      color: i,
      'i': (i == 0)?0:7, 
      'j': (j == 0)?1:6, 
      can_move: function (token, tile) {
        return 
          (token.i == tile.i + 1 && (token.j == tile.j +2 || token.j == tile.j -2)) || 
          (token.i == tile.i + 2 && (token.j == tile.j +1 || token.j == tile.j -1)) || 
          (token.i == tile.i - 1 && (token.j == tile.j +2 || token.j == tile.j -2)) || 
          (token.i == tile.i - 2 && (token.j == tile.j +1 || token.j == tile.j -1));
      }
    }
  }
  rule round {
    (i < @players) turn (i);
  }
  rule turn (i) {
       if (!mate(i)) {
        token = select "token_jugador_".i | "Seleccione una pieza";
        tile = select "tile" as tile where token->can_move (token, tile) AND tile !@ "token_jugador_".i;  | "Seleccione una casilla"
        move token to tile | "Movimiento 
      }else {
        
      }
  }
}


<box>
  <component>
    <name>board</name>
    <components i="10" j="20">
      <component>
        <name>tile_$i_$j</name>
      </component>
